spring.application.name=portfolioforge-backend


# ===================================================================
# PortfolioForge Backend Application Properties
# ===================================================================

# == Server Configuration ==
# Defines the port the embedded Tomcat server will run on.
# Default is 8080 if not specified.
server.port=8080

# == MySQL Database Configuration ==
# URL for connecting to your MySQL database.
# - Replace 'localhost:3306' if your MySQL server is hosted elsewhere.
# - Replace 'portfolioforge_db' with the actual name of the database schema you created.
# - '?useSSL=false' disables SSL for local/dev environments (consider enabling for production).
# - '&serverTimezone=UTC' sets the timezone for the connection (adjust if necessary).
# - '&allowPublicKeyRetrieval=true' may be needed for some MySQL auth methods/versions.
# - Ensure the MySQL server is running and accessible at the specified host and port.
# - If using Docker, ensure the MySQL container is linked correctly and the port is exposed.
# - in development, you can create the database schema with '&createDatabaseIfNotExist=true' to auto-create it if it doesn't exist.
# - in development, you can auto update schema with '&createDatabaseIfNotExist=true' to auto-create it if it doesn't exist.`

spring.datasource.url=jdbc:mysql://localhost:3308/portfolioforge_db?useSSL=false&serverTimezone=UTC&allowPublicKeyRetrieval=true&createDatabaseIfNotExist=true

# Credentials for accessing the MySQL database.
# Replace 'your_mysql_user' with your MySQL username (e.g., 'root' or a dedicated user).
# Replace 'your_mysql_password' with the corresponding password.
# !! Avoid committing actual passwords to Git. Use environment variables or Spring profiles for production. !!
spring.datasource.username=root
spring.datasource.password=my_secret_password

# Specifies the JDBC Driver class name for MySQL.
spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver

# == JPA / Hibernate Configuration ==
# Strategy for Hibernate's Data Definition Language (DDL) generation.
# - 'update': Attempts to update the schema based on entity definitions on startup. Good for development.
# - 'validate': Validates the existing schema against entity definitions, makes no changes. Recommended for production with migration tools.
# - 'create': Drops and recreates the schema on every startup. Loses all data.
# - 'create-drop': Creates schema on startup, drops it on shutdown. Good for some testing scenarios.
# - 'none': Disables DDL generation.
spring.jpa.hibernate.ddl-auto=update

# Logs the SQL statements generated by Hibernate to the console. Useful for debugging.
spring.jpa.show-sql=true

# Properties passed directly to Hibernate.
# 'hibernate.format_sql=true': Pretty-prints the SQL logs for better readability.
spring.jpa.properties.hibernate.format_sql=true
# 'hibernate.dialect': Specifies the SQL dialect for MySQL. Spring Boot usually auto-detects this,
# but explicitly setting it can prevent potential issues. Use the appropriate dialect for your MySQL version (e.g., MySQL8Dialect, MySQL57Dialect).
# Using 'MySQLDialect' is generally safe as it maps to the latest supported dialect by Hibernate version.
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect

# Optional: Naming strategies for tables and columns (if you prefer snake_case over camelCase for DB objects)
# spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
# spring.jpa.hibernate.naming.implicit-strategy=org.springframework.boot.orm.jpa.hibernate.SpringImplicitNamingStrategy

# == Spring Security Configuration (Initial Defaults) ==
# If Spring Security is included, it secures endpoints by default.
# Default username is 'user', password generated and logged at startup.
# You will configure this properly later (e.g., with JWT or specific user details service).
# No explicit properties needed here for the initial default setup.

# == Actuator Configuration (Optional, useful for monitoring) ==
# management.endpoints.web.exposure.include=health,info # Expose health and info endpoints

# ===================================================================
# Make sure to create the 'portfolioforge_db' database in your MySQL
# server before running the application for the first time.
# Remember to replace placeholders like 'your_mysql_user' and
# 'your_mysql_password' with your actual credentials.
# For production, manage sensitive credentials securely (e.g., env vars).
# ===================================================================


# --- JWT Configuration ---
# IMPORTANT: Use a strong, long, random secret key for production!
# Store this securely (e.g., environment variable, config server), NOT directly in source code.
# For local development, a placeholder is okay initially. Generate one using a tool.
# Example generated key (replace with your own!):
# portfolioforge.jwt.secret======================PortfolioForgeJwtSecret=====================

# Use environment variable for secret in real deployments:
# portfolioforge.jwt.secret=${JWT_SECRET_KEY:ReplaceThisWithAStrongSecretForLocalDevIfNotSetViaEnvVar}
#portfolioforge.jwt.secret=YourSuperSecretKeyForPortfolioForgeAppThatIsLongAndRandom12345 # <<< REPLACE THIS!
portfolioforge.jwt.secret=6YZLjQ23hDEd60YK3KYEMDuLOEhV/A8XMvgDrfjeSLzcWwHn7OdqrpLK44bdB2+Kw9kdqjX9hdP+t5f/rKtRfw== 

# JWT Token validity in milliseconds (e.g., 1 hour = 3600000ms)
# For development, you might use a longer duration. Production might be shorter.
portfolioforge.jwt.expiration-ms=3600000

# --- Spring Security Debug Logging ---
# Set logging level for Spring Security components to DEBUG
logging.level.org.springframework.security=DEBUG

# Optional: Set level for web components if needed, but security is primary focus now
# logging.